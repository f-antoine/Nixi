<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Table of contents</title>
        <style>
/* From extension vscode.markdown-math */
@font-face{font-family:KaTeX_AMS;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype");font-weight:700;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Math;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype");font-weight:700;font-style:italic}@font-face{font-family:KaTeX_Math;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:"KaTeX_SansSerif";src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:"KaTeX_SansSerif";src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:"KaTeX_SansSerif";src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Script;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size1;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size2;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size3;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size4;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Typewriter;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype");font-weight:400;font-style:normal}.katex{font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0;text-rendering:auto;border-color:currentColor}.katex *{-ms-high-contrast-adjust:none!important}.katex .katex-version:after{content:"0.13.0"}.katex .katex-mathml{position:absolute;clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-weight:700;font-style:italic}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{display:inline-table;table-layout:fixed;border-collapse:collapse}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;vertical-align:bottom;position:relative}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;vertical-align:bottom;font-size:1px;width:2px;min-width:2px}.katex .vbox{display:inline-flex;flex-direction:column;align-items:baseline}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{width:0;max-width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{display:inline-block;width:100%;border-bottom-style:solid}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{width:0;position:relative}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{display:inline-block;border:0 solid;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{display:inline-block;width:100%;border-bottom-style:solid}.katex .hdashline{display:inline-block;width:100%;border-bottom-style:dashed}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{display:block;position:absolute;width:100%;height:inherit;fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1}.katex svg path{stroke:none}.katex img{border-style:none;min-width:0;min-height:0;max-width:none;max-height:none}.katex .stretchy{width:100%;display:block;position:relative;overflow:hidden}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{width:100%;position:relative;overflow:hidden}.katex .halfarrow-left{position:absolute;left:0;width:50.2%;overflow:hidden}.katex .halfarrow-right{position:absolute;right:0;width:50.2%;overflow:hidden}.katex .brace-left{position:absolute;left:0;width:25.1%;overflow:hidden}.katex .brace-center{position:absolute;left:25%;width:50%;overflow:hidden}.katex .brace-right{position:absolute;right:0;width:25.1%;overflow:hidden}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{box-sizing:border-box;border:.04em solid}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{box-sizing:border-content;border-top:.049em solid;border-right:.049em solid;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{counter-increment:katexEqnNo;content:"(" counter(katexEqnNo) ")"}.katex .mml-eqn-num:before{counter-increment:mmlEqnNo;content:"(" counter(mmlEqnNo) ")"}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;position:absolute;left:calc(50% + .3em);text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{text-align:left;padding-left:2em}body{counter-reset:katexEqnNo mmlEqnNo}

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.katex-error {
	color: var(--vscode-editorError-foreground);
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="table-of-contents">Table of contents</h1>
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#mark-a-class-as-injectable-with-monobehaviourinjectable-type">Mark a class as injectable with MonoBehaviourInjectable type</a></li>
<li><a href="#nixinjector--injector-used-in-play-mode-scene">NixInjector : Injector used in Play Mode scene</a>
<ul>
<li><a href="#description">Description</a></li>
<li><a href="#nixicontainer">NixiContainer</a>
<ul>
<li><a href="#add-transient-mapping">Add transient mapping</a></li>
<li><a href="#add-singleton-mapping">Add singleton mapping</a></li>
<li><a href="#add-singleton-mapping-with-implementation">Add singleton mapping with implementation</a></li>
<li><a href="#check-if-a-mapping-is-registered">Check if a mapping is registered</a></li>
<li><a href="#resolve-mapping">Resolve mapping</a></li>
<li><a href="#remove-mapping">Remove mapping</a></li>
<li><a href="#register-container-mappings-before-scene-load">Register container mappings before scene load</a></li>
<li><a href="#use-nixinjectfromcontainer-to-inject-a-field-from-container-registrations">Use NixInjectFromContainer to inject a field from container registrations</a></li>
</ul>
</li>
<li><a href="#component-injection">Component Injection</a>
<ul>
<li><a href="#implications-of-injection-on-awake">Implications of injection on Awake</a></li>
</ul>
</li>
<li><a href="#single-component-injection">Single component injection</a>
<ul>
<li><a href="#nixinjectcomponent">NixInjectComponent</a></li>
<li><a href="#nixinjectcomponentfromchildren">NixInjectComponentFromChildren</a></li>
<li><a href="#nixinjectcomponentfromparent">NixInjectComponentFromParent</a></li>
<li><a href="#nixinjectrootcomponent">NixInjectRootComponent</a></li>
<li><a href="#nixinjectrootcomponent-with-only-rootgameobjectname-passed-as-parameter">NixInjectRootComponent with only rootGameObjectName passed as parameter</a></li>
<li><a href="#nixinjectrootcomponent-with-rootgameobjectname-and-subgameobjectname-passed-as-parameters">NixInjectRootComponent with rootGameObjectName and subGameObjectName passed as parameters</a></li>
<li><a href="#using-interface-instead-of-components">Using interface instead of components</a></li>
</ul>
</li>
<li><a href="#multiple-components-injection">Multiple components injection</a>
<ul>
<li><a href="#nixinjectcomponents">NixInjectComponents</a></li>
<li><a href="#nixinjectcomponentsfromchildren">NixInjectComponentsFromChildren</a></li>
<li><a href="#nixinjectcomponentsfromparent">NixInjectComponentsFromParent</a></li>
<li><a href="#using-interface-instead-of-components-multiple-components-injection">Using interface instead of components (Multiple components injection)</a></li>
</ul>
</li>
<li><a href="#special-cases">Special cases</a>
<ul>
<li><a href="#serializefield">SerializeField</a></li>
<li><a href="#multiple-nixi-attributes">Multiple Nixi attributes</a></li>
<li><a href="#gameobject-vs-component">GameObject VS Component</a></li>
<li><a href="#the-difference-with-unity-dependency-injection-in-multiple-components-injection">The difference with Unity dependency injection in multiple components injection</a></li>
<li><a href="#multiple-scenes">Multiple scenes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#testinjector--injector-used-for-tests">TestInjector : Injector used for Tests</a>
<ul>
<li><a href="#description-1">Description</a></li>
<li><a href="#recursion-in-testinjector">Recursion in TestInjector</a></li>
<li><a href="#using-testinjector">Using TestInjector</a>
<ul>
<li><a href="#setting-up-your-unity-project-for-testing">Setting up your Unity project for testing</a></li>
<li><a href="#in-newly-created-unity-project-that-has-no-configuration-for-testing-full-tutorial">In newly created Unity project that has no configuration for testing (full tutorial)</a></li>
</ul>
</li>
<li><a href="#fields-accesses">Fields accesses</a>
<ul>
<li><a href="#mock-on-nixinjectfromcontainer-and-serializefield-decorators">Mock on NixInjectFromContainer and SerializeField decorators</a></li>
<li><a href="#single-component-injection-decorators">Single component injection decorators</a>
<ul>
<li><a href="#fields-with-type-derived-from-component">Fields with type derived from component</a></li>
<li><a href="#fields-with-type-derived-from-interface">Fields with type derived from interface</a></li>
</ul>
</li>
<li><a href="#multiple-components-injection-decorators">Multiple components injection decorators</a>
<ul>
<li><a href="#enumerable-fields-with-enumerable-type-derived-from-component">Enumerable fields with &quot;enumerable type&quot; derived from component</a></li>
<li><a href="#enumerable-fields-with-enumerable-type-derived-from-interface">Enumerable fields with &quot;enumerable type&quot; derived from interface</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#injectabletesttemplate">InjectableTestTemplate</a>
<ul>
<li><a href="#how-to-use-injectabletesttemplate">How to use InjectableTestTemplate</a></li>
</ul>
</li>
<li><a href="#tests-with-single-component">Tests with single component</a>
<ul>
<li><a href="#get-a-single-component-with-type">Get a single component with type</a></li>
<li><a href="#get-a-single-component-with-type-and-name">Get a single component with type and name</a></li>
<li><a href="#more-informations-about-getcomponent">More informations about GetComponent</a>
<ul>
<li><a href="#nixinjectcomponentfromparent-and-nixinjectcomponentfromchildren-decorators">NixInjectComponentFromParent and NixInjectComponentFromChildren decorators</a></li>
<li><a href="#nixinjectcomponent-decorator">NixInjectComponent decorator</a></li>
<li><a href="#nixinjectrootcomponent-with-only-rootgameobjectname-parameter-decorator">NixInjectRootComponent with only rootGameObjectName parameter decorator</a></li>
<li><a href="#nixinjectrootcomponent-with-rootgameobjectname-and-subgameobjectname-parameters-decorator">NixInjectRootComponent with rootGameObjectName and subGameObjectName parameters decorator</a></li>
<li><a href="#nixinjectrootcomponent-special-case-where-you-want-your-maintested-instance-to-be-recognized-as-a-root-gameobject">NixInjectRootComponent, special case where you want your MainTested instance to be recognized as a root GameObject</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tests-with-multiple-components">Tests with multiple components</a>
<ul>
<li><a href="#fields-decorated-with-a-nixi-attribute-for-multiple-components-fields">Fields decorated with a Nixi attribute for multiple components fields</a></li>
<li><a href="#initenumerablecomponents">InitEnumerableComponents</a></li>
<li><a href="#initenumerablecomponentswithtypes">InitEnumerableComponentsWithTypes</a></li>
<li><a href="#initsingleenumerablecomponents">InitSingleEnumerableComponents</a></li>
<li><a href="#getenumerablecomponents">GetEnumerableComponents</a></li>
</ul>
</li>
<li><a href="#tests-with-mockable-fields">Tests with mockable fields</a>
<ul>
<li><a href="#inject-and-read-fields">Inject and read fields</a></li>
<li><a href="#inject-field-for-nixinjectfromcontainer-or-serializefield">Inject field for NixInjectFromContainer or SerializeField</a></li>
<li><a href="#mock-single-component-field-decorating-an-interface-eg--nixinjectcomponent">Mock single component field decorating an interface (e.g : NixInjectComponent)</a></li>
<li><a href="#mock-multiple-components-field-having-an-interface-as-enumerable-type-eg--nixinjectcomponents">Mock multiple components field having an interface as enumerable type (e.g : NixInjectComponents)</a></li>
</ul>
</li>
<li><a href="#details-of-other-features-of-injectabletesttemplate">Details of other features of InjectableTestTemplate</a>
<ul>
<li><a href="#instancename-property">InstanceName property</a></li>
<li><a href="#resettemplate-method">ResetTemplate method</a></li>
<li><a href="#settemplatewithconstructor-property">SetTemplateWithConstructor property</a></li>
<li><a href="#using-abstractcomponentmappingcontainer">Using AbstractComponentMappingContainer</a></li>
<li><a href="#template-with-nunit-framework">Template with NUnit framework</a></li>
</ul>
</li>
<li><a href="#special-cases-1">Special cases</a>
<ul>
<li><a href="#multiple-transform-components">Multiple Transform components</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#support">Support</a></li>
</ul>
<h1 id="mark-a-class-as-injectable-with-monobehaviourinjectable-type">Mark a class as injectable with MonoBehaviourInjectable type</h1>
<p><strong>To use Nixi, you have to inherit your classes from MonoBehaviourInjectable instead of MonoBehaviour.</strong></p>
<p>MonoBehaviourInjectable class was designed to call <em>CheckAndInjectAll</em> method during <em>Awake</em> call. The purpose of this method is to inject all fields decorated with Nixi attributes.</p>
<blockquote>
<p>The test template (InjectableTestTemplate) uses a generic type which has for constraint to be a class derived from MonoBehaviourInjectable.
This is because this template can reuse all decorators to simulate Unity and simplify test writing.</p>
</blockquote>
<p><strong>An injector (NixInjector or TestInjector) can call CheckAndInjectAll() only once.</strong></p>
<p>If you want to use <em>Awake</em> in your code and keep the same behaviour, you can override it and call <em>base.Awake()</em>.</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// If you want to use Awake you can override it</span>
    <span class="hljs-comment">// and call base.Awake() to apply injection</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// My logic before injection</span>

        <span class="hljs-keyword">base</span>.Awake();

        <span class="hljs-comment">// My logic after injection</span>
    }
}
</div></code></pre>
<p>If you want to apply injection at another time, you have to :</p>
<ul>
<li>Override <em>Awake</em> method to not call <em>CheckAndInjectAll</em>.</li>
<li>Then you can and use a NixInjector manually like below.</li>
</ul>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Canceling build injection on Awake</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span>
    {
    }

    <span class="hljs-comment">// Build injection at Start</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// injector.IsInjected = false</span>
        NixInjector injector = <span class="hljs-keyword">new</span> NixInjector(<span class="hljs-keyword">this</span>);

        <span class="hljs-comment">// injector.IsInjected = true, cannot be called twice</span>
        injector.CheckAndInjectAll();
    }
}
</div></code></pre>
<h1 id="nixinjector--injector-used-in-play-mode-scene">NixInjector : Injector used in Play Mode scene</h1>
<h2 id="description">Description</h2>
<p>This class performs the injections when the scene is launched in play mode.</p>
<p>It is instantiated and injected during Awake method call in MonoBehaviourInjectable.</p>
<h2 id="nixicontainer">NixiContainer</h2>
<p>This is a simple IOC container in which each mapping must have an interface as key type.</p>
<p>NixiContainer being a static class means that it is not limited to a scene but to the entire &quot;code execution&quot;.</p>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
If the key type is not an interface, an exception will be thrown.</p>
</blockquote>
<p>It has the following features :</p>
<ul>
<li><a href="#add-transient-mapping">Add transient mapping</a></li>
<li><a href="#add-singleton-mapping">Add singleton mapping</a></li>
<li><a href="#add-singleton-mapping-with-implementation">Add singleton mapping with implementation</a></li>
<li><a href="#check-if-a-mapping-is-registered">Check if a mapping is registered</a></li>
<li><a href="#resolve-mapping">Resolve mapping</a></li>
<li><a href="#remove-mapping">Remove mapping</a></li>
</ul>
<p>You can initialize NixiContainer and use it by following :</p>
<ul>
<li><a href="#register-container-mappings-before-scene-load">Register container mappings before scene load</a></li>
<li><a href="#use-nixinjectfromcontainer-to-inject-a-field-from-container-registrations">Use NixInjectFromContainer to inject a field from container registrations</a></li>
</ul>
<h3 id="add-transient-mapping">Add transient mapping</h3>
<p>You can add a mapping with &quot;transient scope&quot;, this scope means that <strong>a new instance is created each time you resolve its mapping</strong> like in the example below.</p>
<p>You can't map an &quot;implementation class&quot; inherited from Component because I didn't want NixiContainer to handle GameObject building (maybe this should be changed).</p>
<p>Instead, I implemented a solution to be able to map this type of implementation by passing an implementation from the scene.</p>
<p>You can read how to use it in <a href="#add-singleton-mapping-with-implementation">Add singleton mapping with implementation part</a>.</p>
<blockquote>
<p>By default there is no need to pass the &quot;constructorParameters&quot; argument, if so the container will use the default constructor to construct the implementation. But you can use different constructor by filling as many parameter as you want in &quot;constructorParameters&quot;.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMappings</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Register link between ISimpleInterface and SimpleImplementation as transient</span>
    NixiContainer.MapTransient&lt;ISimpleInterface, SimpleImplementation&gt;();

    <span class="hljs-comment">// Resolve create an instance</span>
    ISimpleInterface instance = NixiContainer.ResolveMap&lt;ISimpleInterface&gt;();

    <span class="hljs-comment">// Resolve create a different instance</span>
    ISimpleInterface differentInstance = NixiContainer.ResolveMap&lt;ISimpleInterface&gt;();
}
</div></code></pre>
<h3 id="add-singleton-mapping">Add singleton mapping</h3>
<p>You can add a mapping with &quot;singleton scope&quot;, this scope means that <strong>the first mapping resolution call creates the instance and that every subsequent call always returns that same instance</strong> like in the example below.</p>
<p>You can't map an &quot;implementation class&quot; inherited from Component because I didn't want NixiContainer to handle GameObject building (maybe this should be changed).</p>
<p>Instead, I implemented a solution to be able to map this type of implementation by passing an implementation from the scene. You can read how to use it in <a href="#add-singleton-mapping-with-implementation">Add singleton mapping with implementation part</a>.</p>
<blockquote>
<p>By default there is no need to pass the &quot;constructorParameters&quot; argument, if so the container will use the default constructor to construct the implementation.<br/>
But you can use different constructor by filling as many parameter as you want in &quot;constructorParameters&quot;.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMappings</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Register link between ISimpleInterface and SimpleImplementation as singleton</span>
    NixiContainer.MapSingleton&lt;ISimpleInterface, SimpleImplementation&gt;();

    <span class="hljs-comment">// First resolution create a new instance</span>
    ISimpleInterface instance = NixiContainer.ResolveMap&lt;ISimpleInterface&gt;();

    <span class="hljs-comment">// Subsequent resolutions always return the same instance as the first resolution call</span>
    ISimpleInterface sameInstance = NixiContainer.ResolveMap&lt;ISimpleInterface&gt;();
}
</div></code></pre>
<h3 id="add-singleton-mapping-with-implementation">Add singleton mapping with implementation</h3>
<p>Like in <a href="#add-singleton-mapping">Add singleton mapping</a> part, you can add a mapping with &quot;singleton scope&quot;.<br/>
But this time you have to pass an implementation directly, it means that <strong>every mapping resolution call will return the implementation you passed before and NixiContainer will not handle its construction</strong>.</p>
<p>You can see an example below.</p>
<blockquote>
<p>With this method, you can map every type of implementation class, including Component. <br/>
This was also created to allow passing implementations from the scene.</p>
</blockquote>
<pre><code class="language-cs"><div>[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> MonoBehaviourImplementation PrefabFromTheScene;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddMappings</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Register link between ISimpleInterface and MonoBehaviourImplementation as singleton</span>
    <span class="hljs-comment">// The prefab to get from resolution is passed into this mapping</span>
    NixiContainer.MapSingletonWithImplementation&lt;ISimpleInterface, MonoBehaviourImplementation&gt;(PrefabFromTheScene);

    <span class="hljs-comment">// All resolutions return PrefabFromTheScene instance</span>
    ISimpleInterface instance = NixiContainer.ResolveMap&lt;ISimpleInterface&gt;();
}
</div></code></pre>
<h3 id="check-if-a-mapping-is-registered">Check if a mapping is registered</h3>
<p>You can check if a mapping is already registered with the command shown in the example below.</p>
<pre><code class="language-cs"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoLogic</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">bool</span> isRegistered = NixiContainer.CheckIfMappingRegistered&lt;ISimpleInterface&gt;();

    NixiContainer.MapSingleton&lt;ISimpleInterface, SimpleImplementation&gt;();

    <span class="hljs-comment">// true</span>
    isRegistered = NixiContainer.CheckIfMappingRegistered&lt;ISimpleInterface&gt;();
}
</div></code></pre>
<h3 id="resolve-mapping">Resolve mapping</h3>
<p>After adding one or more mappings in NixiContainer, you can retrieve an instance from a key type (interface) as shown in the example below.</p>
<blockquote>
<p>This example does not cover all scenarios in terms of scope, if you want to know more about registration scopes you can read these parts :</p>
<ul>
<li><a href="#add-transient-mapping">Add transient mapping</a></li>
<li><a href="#add-singleton-mapping">Add singleton mapping</a></li>
<li><a href="#add-singleton-mapping-with-implementation">Add singleton mapping with implementation</a></li>
</ul>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoLogic</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Register link between ISimpleInterface and SimpleImplementation as transient</span>
    NixiContainer.MapTransient&lt;ISimpleInterface, SimpleImplementation&gt;();

    <span class="hljs-comment">// Resolve create an instance</span>
    ISimpleInterface instance = NixiContainer.ResolveMap&lt;ISimpleInterface&gt;();
}
</div></code></pre>
<h3 id="remove-mapping">Remove mapping</h3>
<p>You can remove a mapping with the command shown in the example below.</p>
<pre><code class="language-cs"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoLogic</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Add mapping</span>
    NixiContainer.MapSingleton&lt;ISimpleInterface, SimpleImplementation&gt;();

    <span class="hljs-comment">// Remove mapping</span>
    NixiContainer.RemoveMap&lt;ISimpleInterface&gt;();
}
</div></code></pre>
<h3 id="register-container-mappings-before-scene-load">Register container mappings before scene load</h3>
<p>To load all NixiContainer configurations before all other scripts, there are several possible approaches.</p>
<p>I use one of the following :</p>
<ul>
<li>
<p>You can create a static class with <em>RuntimeInitializeOnLoadMethod</em> decorator to choose when it should be call (no need to have a script in the scene) like in the example below.</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ContainerConfiguration</span>
{
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Create all mappings between interfaces and implementations used in NixiContainer after that assemblies are loaded</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> You can change the RuntimeInitializeLoadType to best suit your situation</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    [<span class="hljs-meta">RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)</span>]
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LinkFieldInjections</span>(<span class="hljs-params"></span>)</span>
    {
        NixiContainer.MapSingleton&lt;ISimpleInterface, SimpleImplementation&gt;();
    }
}
</div></code></pre>
</li>
<li>
<p>Or you can create a MonoBehaviour script like this one :</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ContainerInitiliazer</span> : <span class="hljs-title">MonoBehaviour</span>
{
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Create all mappings between interfaces and implementations used in NixiContainer after that assemblies are loaded</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span>
    {
        NixiContainer.MapSingleton&lt;ISimpleInterface, SimpleImplementation&gt;();
    }
}
</div></code></pre>
<p>Then you can attached it to a GameObject in the scene and change the Script Execution Order located in :</p>
<pre><code>    -&gt; Edit in the menu bar
        -&gt; Project Settings
            -&gt; Script Execution Order (tab)
</code></pre>
<p>Lastly, you can add your script in the list and drag it to have it before &quot;Default time&quot;, this will ensure it will be called before your scripts when the scene is loaded.</p>
</li>
</ul>
<h3 id="use-nixinjectfromcontainer-to-inject-a-field-from-container-registrations">Use NixInjectFromContainer to inject a field from container registrations</h3>
<p>After registering the mappings, you can inject a field whose type matches a record from the NixInjectFromContainer decorator like in the example below.</p>
<pre><code class="language-cs"><div><span class="hljs-comment">// This class will injects the fields decorated with Nixi attributes</span>
<span class="hljs-comment">// on Awake() call because it is inherited from MonoBehaviourInjectable</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectFromContainer</span>]
    <span class="hljs-keyword">private</span> ISimpleInterface instance;
}
</div></code></pre>
<h2 id="component-injection">Component Injection</h2>
<p><a href="#nixicontainer">NixiContainer</a> can handle the construction of classes that are not Unity components and register some component with object passed from the scene. But in Play Mode scene Nixi never builds Unity components and we won't store everything in the NixiContainer, especially since we have Unity dependency injection available (with methods like <em>GetComponent<Slider>()</em>).</p>
<p>For all Unity components or classes derived from it, or even interfaces implemented on Unity components, there are specific Nixi attributes.</p>
<p><strong>Nixi attributes for Unity components use Unity dependency injection methods when <em>Awake</em> method is called in classes derived from MonoBehaviourInjectable.</strong></p>
<p>This applies on classes derived from component type and on interfaces implemented on components present in the scene.</p>
<blockquote>
<p>Inheritance is taken into account, which means that if you try to fill a field with &quot;Renderer&quot; type, it may find a SpriteRenderer like a MeshRenderer. If you want more precision you can, by example, directly specify the last descendant type.</p>
</blockquote>
<h3 id="implications-of-injection-on-awake">Implications of injection on Awake</h3>
<p>Fields decorated with Nixi attributes are injected during <em>Awake()</em> method call of a MonoBehaviourInjectable, this means :</p>
<ul>
<li>That it will be injected only when the MonoBehaviourInjectable is at the beginning of its life cycle in the scene and anything not available at this moment cannot be injected with Nixi later.</li>
<li>Anything created after cannot update what is already initialized/injected into the scene.
<blockquote>
<p>By example, if a spawner creates a monster, the spawner will have to handle this new instance (this new monster will also have an initialization phase and can have its fields injected if it is MonoBehaviourInjectable but the spawner will not be updated even if by example he had injected one of its fields with all the monsters present in the scene during its initialization).</p>
</blockquote>
</li>
</ul>
<h2 id="single-component-injection">Single component injection</h2>
<p>A single component field is a field which has a type derived from Unity component.</p>
<p>Contrary to a <a href="#multiple-components-injection">Multiple components injection</a>, it handle only one instance and not an Enumerable of component instances.</p>
<p>A single component injection is an injection performed in a single component field decorated with one of the Nixi attributes provided for this when calling the <em>Awake</em> method of a MonoBehaviourInjectable.</p>
<blockquote>
<p>It can be on a field with an interface type which is implemented on an Unity component present in the scene.</p>
<p>You can find more information about interface type combined with single component injection <a href="#using-interface-instead-of-components">into this part</a>.</p>
</blockquote>
<p>Here is the list of Nixi attributes that handle <strong>single component injection</strong> :</p>
<ul>
<li><a href="#nixinjectcomponent">NixInjectComponent</a></li>
<li><a href="#nixinjectcomponentfromchildren">NixInjectComponentFromChildren</a></li>
<li><a href="#nixinjectcomponentfromparent">NixInjectComponentFromParent</a></li>
<li><a href="#nixinjectrootcomponent">NixInjectRootComponent</a></li>
</ul>
<h3 id="nixinjectcomponent">NixInjectComponent</h3>
<p>When a field is decorated with NixInjectComponent, as in the example below, NixInjector will get the single component attached to its own GameObject that match the field type.</p>
<blockquote>
<p>If you want to get multiple components of the same type present on its own GameObject, <a href="#NixInjectComponents">you can use NixInjectComponents</a>.</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
If component not found or multiple are returned, an exception will be thrown.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call GetComponents&lt;BoxCollider2D&gt; from current GameObject</span>
    <span class="hljs-comment">// and find the single component with BoxCollider2D type attached to this GameObject</span>
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D colliderToInject;
}
</div></code></pre>
<h3 id="nixinjectcomponentfromchildren">NixInjectComponentFromChildren</h3>
<p>When a field is decorated with NixInjectComponentFromChildren, as in the example below, NixInjector will get the single component attached to one of its child GameObjects that match the field type (<strong>excluding itself</strong>, which differs from Unity).</p>
<p>If multiple GameObjects with a component of the searched type can be found, you can specify the <em>gameObjectName</em> parameter, this will filter GameObjects found to keep the one with that name to find the unique match.</p>
<blockquote>
<p>If you want to get multiple components of same type in children, <a href="#NixInjectComponentsFromChildren">you can use NixInjectComponentsFromChildren</a>.</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
If component not found or multiple are returned, an exception will be thrown.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call GetComponentsInChildren&lt;BoxCollider2D&gt; from the current GameObject </span>
    <span class="hljs-comment">// and find the single BoxCollider2D type component attached to any of its child GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentFromChildren</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D colliderToInject;
}
</div></code></pre>
<h3 id="nixinjectcomponentfromparent">NixInjectComponentFromParent</h3>
<p>When a field is decorated with NixInjectComponentFromParent, as in the example below, NixInjector will get the single component attached to one of its parent GameObjects that match the field type (<strong>excluding itself</strong>, which differs from Unity).</p>
<p>If multiple GameObjects with a component of the searched type can be found, you can specify the gameObjectName parameter, this will filter GameObjects found to keep the one with that name to find the unique match.</p>
<blockquote>
<p>If you want to get multiple components of same type in parents, <a href="#NixInjectComponentsFromParent">you can use NixInjectComponentsFromParent</a>.</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
If component not found or multiple are returned, an exception will be thrown.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call GetComponentsInParent&lt;BoxCollider2D&gt; from the current GameObject</span>
    <span class="hljs-comment">// and find the single BoxCollider2D type component attached to any of its parent GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentFromParent</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D colliderToInject;
}
</div></code></pre>
<h3 id="nixinjectrootcomponent">NixInjectRootComponent</h3>
<p>In Unity, a <strong>root GameObject</strong> is a GameObject that is at the first level of the scene (top most).</p>
<p>It has no parents and is often harder to access from Nixi attributes, especially if you're looking for a GameObject from a GameObject that can't find it in its parents (because it's a descendant of another root GameObject or a root GameObject directly).</p>
<p>That's why <strong>NixInjectRootComponent</strong> was created.</p>
<blockquote>
<p>In this documentation, a <strong>root component</strong> is a component attached to a root GameObject or attached to one of its child GameObject.</p>
</blockquote>
<p>NixInjector will get the single root component which match the field type and parameter(s) :</p>
<ul>
<li>Required first parameter <a href="#nixinjectrootcomponent-with-only-rootgameobjectname-passed-as-parameter">rootGameObjectName</a>.</li>
<li>Optional second parameter <a href="#nixinjectrootcomponent-with-rootgameobjectname-and-subgameobjectname-passed-as-parameters">subGameObjectName</a>.</li>
</ul>
<h3 id="nixinjectrootcomponent-with-only-rootgameobjectname-passed-as-parameter">NixInjectRootComponent with only rootGameObjectName passed as parameter</h3>
<p>When a field is decorated with NixInjectRootComponent with only rootGameObjectName parameter filled, as in the example below, NixInjector will :</p>
<ul>
<li>Get the unique root GameObject which has a name equal to rootGameObjectName.</li>
<li>And from that root GameObject it will find the single component attached to this root GameObject that match the field type.</li>
</ul>
<blockquote>
<p>There is no Nixi attribute provided to fetch multiple components from root GameObjects, this is to avoid more expensive method calls (from my perspective if I wanted to fetch all children of a type descended from a root GameObject, I will give access and responsibility to these child components to a component attached to the root GameObject)</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/></p>
<ul>
<li>If root GameObject not found or multiple are returned, an exception will be thrown.</li>
<li>If component not found or multiple are returned, an exception will be thrown.</li>
</ul>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call UnityEngine.SceneManagement.SceneManager.GetActiveScene().GetRootGameObjects()</span>
    <span class="hljs-comment">// then find the single root GameObject named &quot;rootGameObjectName&quot;</span>
    <span class="hljs-comment">// and find the single component with BoxCollider2D type attached to this root GameObject</span>
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;rootGameObjectName&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D colliderToInject;
}
</div></code></pre>
<h3 id="nixinjectrootcomponent-with-rootgameobjectname-and-subgameobjectname-passed-as-parameters">NixInjectRootComponent with rootGameObjectName and subGameObjectName passed as parameters</h3>
<p>When a field is decorated with NixInjectRootComponent with rootGameObjectName and subGameObjectName parameters filled, as in the example below, NixInjector will :</p>
<ul>
<li>Get the unique root GameObject which has a name equal to rootGameObjectName.</li>
<li>And from that root GameObject it will find the single child GameObject which has name equals to subGameObjectName.</li>
<li>And from that subGameObject it will find the single component attached that match the field type.</li>
</ul>
<blockquote>
<p>There is no Nixi attribute provided to fetch multiple components from root GameObjects, this is to avoid more expensive method calls (from my perspective if I wanted to fetch all children of a type descended from a root GameObject, I will give access and responsibility to these child components to a component attached to the root GameObject)</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/></p>
<ul>
<li>If root GameObject not found or multiple are returned, an exception will be thrown.</li>
<li>If subGameObject not found or multiple are returned, an exception will be thrown.</li>
<li>If component not found or multiple are returned, an exception will be thrown.</li>
</ul>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call UnityEngine.SceneManagement.SceneManager.GetActiveScene().GetRootGameObjects()</span>
    <span class="hljs-comment">// then find the single root GameObject named &quot;rootGameObjectName&quot;</span>
    <span class="hljs-comment">// then find the single child GameObject named &quot;subGameObjectName&quot;</span>
    <span class="hljs-comment">// and find the single component with BoxCollider2D type attached to this root GameObject</span>
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;rootGameObjectName&quot;</span>, <span class="hljs-meta-string">&quot;subGameObjectName&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D colliderToInject;
}
</div></code></pre>
<h3 id="using-interface-instead-of-components">Using interface instead of components</h3>
<p>For each component injection, it is possible to use an interface instead of a component.</p>
<p>To do this, you have to</p>
<ul>
<li>Implement an interface on a MonoBehaviour script.</li>
<li>Attach this script to a GameObject presents in the scene.</li>
<li>Decorate the field (which has the type of the interface) in which you would like to inject the target component from a Nixi attribute.</li>
</ul>
<blockquote>
<p>Unity dependendy injection can retrieve components as well as components implementing interfaces present in the scene using the same methods, which is why Nixi can also do it.</p>
</blockquote>
<p>You can see an example below.</p>
<pre><code class="language-cs"><div><span class="hljs-comment">// If a GameObject has an Hero component and a LifeBar component attached to it,</span>
<span class="hljs-comment">// the LifeBar component will be injected into the lifeBar variable in the Hero component.</span>
<span class="hljs-comment">// This variable will therefore depend on an abstraction and not on an implementation.</span>

<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ILifeBar</span>
{
    <span class="hljs-keyword">int</span> HealthPoints { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LifeBar</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">ILifeBar</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> HealthPoints =&gt; <span class="hljs-number">123</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">private</span> ILifeBar lifeBar;
}
</div></code></pre>
<h2 id="multiple-components-injection">Multiple components injection</h2>
<p>A multiple components field is a field that is a List, an IEnumerable or an array where the enumerable type is a type derived from Unity component.</p>
<p>Contrary to a <a href="#single-component-injection">Single component injection</a>, it can handle one or several instance(s).</p>
<p>A multiple components injection is an injection performed in a multiple components field decorated with one of the Nixi attributes provided for this when calling the <em>Awake</em> method of a MonoBehaviourInjectable.</p>
<blockquote>
<p>It can be on a field that a List, an IEnumerable or an array where the enumerable type is an interface type which is implemented on one or several Unity component(s) present in the scene.</p>
<p>You can find more information about interface type combined with multiple component(s) injection <a href="#using-interface-instead-of-components-multiple-components-injection">into this part</a>.</p>
</blockquote>
<p>Here is the list of Nixi attributes that handle <strong>multiple components injection</strong> :</p>
<ul>
<li><a href="#nixinjectcomponents">NixInjectComponents</a></li>
<li><a href="#nixinjectcomponentsfromchildren">NixInjectComponentsFromChildren</a></li>
<li><a href="#nixinjectcomponentsfromparent">NixInjectComponentsFromParent</a></li>
</ul>
<h3 id="nixinjectcomponents">NixInjectComponents</h3>
<p>When a field is decorated with NixInjectComponents, as in the example below, NixInjector will get all the components attached to its own GameObject that match the &quot;enumerable type&quot;.</p>
<blockquote>
<p>If you want to get the only component of a type present on its own GameObject, <a href="#NixInjectComponent">you can use NixInjectComponent</a>.</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
It can only decorate IEnumerables, Lists and arrays, otherwise an exception will be thrown.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-comment">// In this example, all fields have the same values,</span>
<span class="hljs-comment">// because they are all at the same level (GetComponents)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call GetComponents on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to this GameObject</span>
    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">private</span> List&lt;Weapon&gt; weaponList;

    <span class="hljs-comment">// Will call GetComponents on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to this GameObject</span>
    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">private</span> IEnumerable&lt;Weapon&gt; weaponEnumerable;

    <span class="hljs-comment">// Will call GetComponents on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to this GameObject</span>
    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">private</span> Weapon[] weaponArray;
}
</div></code></pre>
<h3 id="nixinjectcomponentsfromchildren">NixInjectComponentsFromChildren</h3>
<p>When a field is decorated with NixInjectComponentsFromChildren, as in the example below, NixInjector will get all the components attached to its child GameObjects (<strong>excluding itself</strong> , which differs from Unity) that match the &quot;enumerable type&quot;.</p>
<blockquote>
<p>If you want to get the only component of a type present in its own child GameObjects, <a href="#NixInjectComponentFromChildren">you can use NixInjectComponentFromChildren</a>.</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
It can only decorate IEnumerables, Lists and arrays, otherwise an exception will be thrown.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-comment">// In this example, all fields have the same values,</span>
<span class="hljs-comment">// because they are all at the same level (GetComponentsInChildren)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call GetComponentsInChildren on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to its child GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentsFromChildren</span>]
    <span class="hljs-keyword">private</span> List&lt;Weapon&gt; weaponList;

    <span class="hljs-comment">// Will call GetComponentsInChildren on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to its child GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentsFromChildren</span>]
    <span class="hljs-keyword">private</span> IEnumerable&lt;Weapon&gt; weaponEnumerable;

    <span class="hljs-comment">// Will call GetComponentsInChildren on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to its child GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentsFromChildren</span>]
    <span class="hljs-keyword">private</span> Weapon[] weaponArray;
}
</div></code></pre>
<h3 id="nixinjectcomponentsfromparent">NixInjectComponentsFromParent</h3>
<p>When a field is decorated with NixInjectComponentsFromParent, as in the example below, NixInjector will get all the components attached to its parent GameObjects (<strong>excluding itself</strong> , which differs from Unity) that match the &quot;enumerable type&quot;.</p>
<blockquote>
<p>If you want to get the only component of a type present in its own parent GameObjects, <a href="#NixInjectComponentFromParent">you can use NixInjectComponentFromParent</a>.</p>
</blockquote>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
It can only decorate IEnumerables, Lists and arrays, otherwise an exception will be thrown.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-comment">// In this example, all fields have the same values,</span>
<span class="hljs-comment">// because they are all at the same level (NixInjectComponentsFromParent)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// Will call NixInjectComponentsFromParent on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to its parent GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentsFromParent</span>]
    <span class="hljs-keyword">private</span> List&lt;Weapon&gt; weaponList;

    <span class="hljs-comment">// Will call NixInjectComponentsFromParent on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to its parent GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentsFromParent</span>]
    <span class="hljs-keyword">private</span> IEnumerable&lt;Weapon&gt; weaponEnumerable;

    <span class="hljs-comment">// Will call NixInjectComponentsFromParent on the current GameObject</span>
    <span class="hljs-comment">// and find all components of type Weapon attached to its parent GameObjects (excluding itself)</span>
    [<span class="hljs-meta">NixInjectComponentsFromParent</span>]
    <span class="hljs-keyword">private</span> Weapon[] weaponArray;
}
</div></code></pre>
<h3 id="using-interface-instead-of-components-multiple-components-injection">Using interface instead of components (Multiple components injection)</h3>
<p>The same rules apply on interfaces usage for multiple components injection as <a href="#using-interface-instead-of-components">interface usage on single component injection</a>.</p>
<p>Instead of a single interface, you will deal with an IEnumerable, a List or an array with enumerable type equals to the interface type you are targeting.</p>
<h2 id="special-cases">Special cases</h2>
<h3 id="serializefield">SerializeField</h3>
<p>You cannot use a Nixi attribute with a SerializeField attribute on the same field, because SerializeField means you are passing the value directly from the scene.</p>
<blockquote>
<p><strong>If this is the case the injector will throw an exception.</strong></p>
</blockquote>
<h3 id="multiple-nixi-attributes">Multiple Nixi attributes</h3>
<p>You cannot use multiple Nixi attributes on the same field because that wouldn't really make sense.</p>
<blockquote>
<p><strong>If this is the case the injector will throw an exception.</strong></p>
</blockquote>
<h3 id="gameobject-vs-component">GameObject VS Component</h3>
<p>A GameObject is not a component, that means, you can't inject it directly into a MonoBehaviourInjectable.</p>
<p>If you want to access it, you can use the Transform type for these two reasons :</p>
<ul>
<li>It is an Unity component.</li>
<li>It contains the GameObject you want to inject.</li>
</ul>
<h3 id="the-difference-with-unity-dependency-injection-in-multiple-components-injection">The difference with Unity dependency injection in multiple components injection</h3>
<p>Like in Unity, when we use NixInjectComponents, only the components on the GameObject that calls the method are returned.</p>
<p>But for NixInjectComponentsFromChildren and NixInjectComponentsFromParent, I chose to do it differently from Unity : the GameObject that calls the method in the components is removed from the results.</p>
<blockquote>
<p>I wanted to differentiate all thoses cases to avoid confusions and allow to be more precise.</p>
</blockquote>
<blockquote>
<p>Moreover, in <a href="#testinjector--injector-used-for-tests">TestInjector part</a>, it makes it easier to link transform and transform.parent for the GameObjects with this approach.</p>
</blockquote>
<h3 id="multiple-scenes">Multiple scenes</h3>
<p>Nixi was written with a focus on single scene context, I don't know what it might imply to use it in a multiple scene context.</p>
<h1 id="testinjector--injector-used-for-tests">TestInjector : Injector used for Tests</h1>
<h2 id="description-1">Description</h2>
<p>This library also aims to facilitate testing on MonoBehaviourInjectables, which is why a specific injector called <strong>TestInjector</strong> has been created for testing purposes only. It was written, thinking of &quot;edit mode tests&quot; which cover most cases that don't require runtime (frame by frame tests with Awake, Start, Update, etc.).</p>
<blockquote>
<p>It is possible to use TestInjector on tests that need to be played at runtime (play mode tests), the usage is no different, you can adapt it at your convenience.</p>
</blockquote>
<p>The Nixi attributes are intended to be used during play mode scene and can also be reused in tests to follow the evolution of these fields and/or mock where it is useful, including non-public fields. These reuses and accesses during testing are intended to simulate and verify Unity context (GetComponent, GetComponentInChildren, etc.), as well as to simulate interfaces that have been decorated for injection from NixiContainer (or decorated with SerializeField).</p>
<p><strong>This is only allowed for these cases, no others.</strong></p>
<p><strong>TestInjector</strong> provides a set of tools that can handle most situations I'm used to seeing to allow focus on testing. These tools help preserve encapsulation, avoid writing workarounds, and rely on Unity dependency injection as well as the more classic dependency injection handled by <a href="#nixicontainer">NixiContainer</a>.</p>
<h2 id="recursion-in-testinjector">Recursion in TestInjector</h2>
<p>Each time TestInjector creates a component (from the detection of a single component injection or a multiple components injection on which data has been initialized), if this component is a MonoBehaviourInjectable, TestInjector will also inject the fields of this component and this, in a recursive way.</p>
<p>You can apply all of the TestInjector's operations to any of recursively generated components, regardless of the number of recursions that have taken place.</p>
<p>To do this, you have to pass the targetInjectable parameter in the methods you want to use.</p>
<blockquote>
<p>If this is parameter is null, MainTested will be the targetInjectable (this is the default behavior).</p>
<p>This parameter can come from any level of recursivity.</p>
</blockquote>
<h2 id="using-testinjector">Using TestInjector</h2>
<h3 id="setting-up-your-unity-project-for-testing">Setting up your Unity project for testing</h3>
<p>If your environment is not configured to use Unity tests you can :</p>
<ul>
<li>Read <a href="https://docs.unity3d.com/Packages/com.unity.test-framework@2.0/manual/index.html">this part of Unity documentation</a>, and :
<ul>
<li>Add <strong>Nixi.dll</strong> and <strong>NixiTestTools.dll</strong> reference to your &quot;Tests&quot; Assembly Definition in &quot;Assembly References&quot; part (below nunit.framework.dll).</li>
<li>Probably have to check the box &quot;Override References&quot; in your &quot;Scripts&quot; Assembly Definition to add <strong>Nixi.dll</strong> in &quot;Assembly References&quot; part continue this part.</li>
</ul>
</li>
<li>Or you can read <a href="#in-newly-created-unity-project-that-has-no-configuration-for-testing-full-tutorial">the full tutorial part</a> described in this documentation to do it from scratch.</li>
</ul>
<h3 id="in-newly-created-unity-project-that-has-no-configuration-for-testing-full-tutorial">In newly created Unity project that has no configuration for testing (full tutorial)</h3>
<ol>
<li>
<p>If Nixi is not installed in your project, please follow <a href="https://github.com/f-antoine/Nixi#getting-started">Getting Started into README page</a>.</p>
</li>
<li>
<p>Setup your &quot;Scripts&quot; assembly :</p>
<ul>
<li>
<p>Create a folder named &quot;Scripts&quot; into your &quot;Assets&quot; folder for your code.</p>
</li>
<li>
<p>Move in this &quot;Scripts&quot; folder and create a simple script to test your environment like this :</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">using</span> Nixi.Injections;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassToTest</span> : <span class="hljs-title">MonoBehaviourInjectable</span> { }
</div></code></pre>
</li>
<li>
<p>Still in &quot;Scripts&quot; folder :</p>
<pre><code>   -&gt; Right click
       -&gt; Click on Create / Assembly Definition
           -&gt; Name it &quot;Scripts&quot;
</code></pre>
</li>
<li>
<p>In this newly created Assembly Definition, if you have some issues about Nixi referencing, you can specify these references as follows :</p>
<ul>
<li>Check the box &quot;Override References&quot;</li>
<li>In &quot;Assembly References&quot; part, add a reference to <strong>Nixi.dll</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Setup your &quot;Tests&quot; assembly :</p>
<ul>
<li>
<p>Move into your &quot;Assets&quot; folder, then :</p>
<pre><code>   -&gt; Click on Window in menu bar
       -&gt; Move into General
           -&gt; Click on Test runner
</code></pre>
</li>
<li>
<p>Click on &quot;Create EditMode Test Assembly Folder&quot;, validate the newly created &quot;Tests&quot; folder and move into this &quot;Tests&quot; folder.</p>
</li>
<li>
<p>Click on &quot;Tests&quot; assembly definition (with the puzzle piece icon)</p>
<ul>
<li>In &quot;Assembly Definition References&quot; part, add the &quot;Scripts&quot; assembly definition.</li>
<li>In &quot;Assembly References&quot; part, add <strong>Nixi.dll</strong> and <strong>Nixi.TestTools</strong> (next to nunit.framework.dll).</li>
</ul>
</li>
<li>
<p>Still in &quot;Tests&quot; folder and from &quot;Test Runner&quot; window, click on : &quot;Create Test Script in current folder&quot;.</p>
</li>
<li>
<p>Name it the way you want and open it, in this script you can write your first test like this :</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">using</span> NixiTestTools;
<span class="hljs-keyword">using</span> NUnit.Framework;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ClassTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">ClassToTest</span>&gt;
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestsWorking</span>(<span class="hljs-params"></span>)</span>
    {
        Assert.NotNull(MainTested);
        Assert.NotNull(MainInjector);
    }
}
</div></code></pre>
</li>
</ul>
</li>
<li>
<p>To check if everything is correctly setup :</p>
<ul>
<li>Return into the Test Runner window, the test should be displayed.</li>
<li>Play this test and if there is no error and the result is green, it means your environment is setup.</li>
</ul>
</li>
</ol>
<blockquote>
<p>If you have any issue using assembly definition in Unity or if you want more informations, you can check into this link : <a href="https://docs.unity3d.com/Manual/ScriptCompilationAssemblyDefinitionFiles.html">https://docs.unity3d.com/Manual/ScriptCompilationAssemblyDefinitionFiles.html</a></p>
</blockquote>
<h2 id="fields-accesses">Fields accesses</h2>
<p>TestInjector allows access to fields decorated with Nixi attributes or with SerializeField.</p>
<p>These accesses are allowed on public, protected and private fields at all levels of inheritance.</p>
<blockquote>
<p>You can skip the parts about design choices about field accesses and go straight to the <a href="#injectabletesttemplate">more concrete parts with code examples</a>.</p>
</blockquote>
<p>The reasons these field accesses are allowed are described along the parts :</p>
<ul>
<li><a href="#mock-on-nixinjectfromcontainer-and-serializefield-decorators">Mock on NixInjectFromContainer and SerializeField decorators</a></li>
<li><a href="#single-component-injection-decorators">Single component injection decorators</a></li>
<li><a href="#multiple-components-injection-decorators">Multiple components injection decorators</a></li>
</ul>
<h3 id="mock-on-nixinjectfromcontainer-and-serializefield-decorators">Mock on NixInjectFromContainer and SerializeField decorators</h3>
<p>If you are not familiar with NixInjectFromContainer, <a href="#use-nixinjectfromcontainer-to-inject-a-field-from-container-registrations">please read this part</a>.</p>
<p>The fields decorated with NixInjectFromContainer or SerializeField are not filled from TestInjector, you will have to mock it and their values will be readable.</p>
<blockquote>
<p>The reasons for being able to access decorated fields with <strong>NixInjectFromContainer</strong> are :</p>
<ul>
<li>It's not the same environment, so by default, the NixiContainer configuration is not loaded.</li>
<li>You can isolate each test situation, mock fields (or use an implementation) and focus on what is important.</li>
</ul>
</blockquote>
<blockquote>
<p>The reasons for being able to access fields decorated with <strong>SerializeField</strong> are :</p>
<ul>
<li>TestInjector responds to test categories that do not need to be linked to a scene (for play mode tests, the situation could be different).</li>
<li>If these fields are not public, they cannot be filled in or read. Especially since the code of the classes must remain independent of the tests and the encapsulation must not be bypassed in order to be able to test.</li>
</ul>
</blockquote>
<h3 id="single-component-injection-decorators">Single component injection decorators</h3>
<p>If you are not familiar with single component decorators, <a href="#single-component-injection">please read this part</a>.</p>
<h4 id="fields-with-type-derived-from-component">Fields with type derived from component</h4>
<p>If a field with a type derived from component is decorated with a Nixi attribute used for single component injection, TestInjector will create a new instance of this type during <em>CheckAndInjectAll</em> method call and will fill the field with this newly created instance.</p>
<blockquote>
<p>The code used during instantiation is : new GameObject().AddComponent&lt;FieldType&gt;().</p>
</blockquote>
<p>This instance will be accessible from TestInjector (as described <a href="#tests-with-single-component">in this part</a>).</p>
<blockquote>
<p>If this new instance has a type derived from MonoBehaviourInjectable it will inject its fields as well, see <a href="#recursion-in-testinjector">recursion part for informations</a>.</p>
</blockquote>
<h4 id="fields-with-type-derived-from-interface">Fields with type derived from interface</h4>
<p>If a Nixi attribute is used for single component injection on a field with an interface type, this will make this field mockable like in <a href="#mock-on-nixinjectfromcontainer-and-serializefield-decorators">Mock on NixInjectFromContainer and SerializeField decorators part</a>.</p>
<p>These fields are not filled from TestInjector, you will have to mock them and their values will be readable.</p>
<blockquote>
<p>There isn't really a way or even a reason to instantiate a GameObject that would implement an interface automatically from TestInjector based on the interface only. The purpose is to not depend on the implementation, it is easier to mock an interface than a GameObject and if you want you can pass an implementation.</p>
</blockquote>
<h3 id="multiple-components-injection-decorators">Multiple components injection decorators</h3>
<p>If you are not familiar with multiple components decorators, <a href="#multiple-components-injection">please read this part</a>.</p>
<h4 id="enumerable-fields-with-enumerable-type-derived-from-component">Enumerable fields with &quot;enumerable type&quot; derived from component</h4>
<p>If a field is a List, an IEnumerable or an array with its &quot;enumerable type&quot; derived from component is decorated with a Nixi attribute used for multiple components injection, TestInjector will fill this field with an empty enumerable during <em>CheckAndInjectAll</em> method call.</p>
<p>Some methods allow you to initialize theses fields with a certain number of instances and these fields can be read, you can see how <a href="#tests-with-multiple-components">in this part</a>.</p>
<blockquote>
<p>If the new instances have a type derived from MonoBehaviourInjectable, they will also have their fields injected, see <a href="#recursion-in-testinjector">recursion part for informations</a>.</p>
</blockquote>
<h4 id="enumerable-fields-with-enumerable-type-derived-from-interface">Enumerable fields with &quot;enumerable type&quot; derived from interface</h4>
<p>If a Nixi attribute is used for multiple components injection on a field  that is a List, an IEnumerable or an array with an &quot;enumerable type&quot; that is an interface, this will make this field mockable like <a href="#mock-on-nixinjectfromcontainer-and-serializefield-decorators">Mock on NixInjectFromContainer and SerializeField decorators part</a>.</p>
<p>These fields are not filled from TestInjector, you will have to mock them and their values will be readable.</p>
<blockquote>
<p>There isn't really a way or even a reason to instantiate a GameObject that would implement an interface automatically from TestInjector based on the interface only. The purpose is to not depend on the implementation, it is easier to mock an interface than a GameObject and if you want you can always pass an implementation.</p>
</blockquote>
<h2 id="injectabletesttemplate">InjectableTestTemplate</h2>
<p>A test template is provided to test classes inherited from MonoBehaviourInjectable using TestInjector, but you can do it from scratch.</p>
<p>This template is called <strong>InjectableTestTemplate</strong> and the most importants things are :</p>
<ul>
<li>It has a property named <strong>MainTested</strong> which is the instance you are testing.</li>
<li>It has a property named <strong>MainInjector</strong>, which is the injector (TestInjector) linked to MainTested. <br/>It is useful to access to components, inject mocks, etc.</li>
</ul>
<p>You can read how to use this template in your tests in the following parts :</p>
<ul>
<li><a href="#how-to-use-injectabletesttemplate">How to use InjectableTestTemplate</a></li>
<li><a href="#tests-with-single-component">Tests with single component</a></li>
<li><a href="#tests-with-multiple-components">Tests with multiple components</a></li>
<li><a href="#tests-with-mockable-fields">Tests with mockable fields</a></li>
<li><a href="#details-of-other-features-of-injectabletesttemplate">Details of other features of InjectableTestTemplate</a></li>
</ul>
<blockquote>
<p>This not necessary to read its source code, but you can find it just below.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Test template for MonoBehaviourInjectable, it creates an instance of the MonoBehaviourInjectable and use TestInjector </span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> to specially handle dependency injection for testing</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;T&quot;&gt;</span>MonoBehaviourInjectable<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">T</span>&gt;
    <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Instance of the tested MonoBehaviourInjectable</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">protected</span> T MainTested { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Injector implemented for tests, it handle all injections of fields decorated with Nixi inject attributes </span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> of a class derived from MonoBehaviourInjectable during test execution</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;para/&gt;</span>His purpose is to simplify access to fields inexposed and make these fields testables/mockables</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">protected</span> TestInjector MainInjector { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Name of the instance, mainly modified to consider MainTested as a root component</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;para/&gt;</span>See documentation part : &quot;NixInjectRootComponent special case when you want your MainTested to be </span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> recognized as a root gameObject&quot;</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">string</span> InstanceName =&gt; <span class="hljs-string">&quot;&quot;</span>;

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> If true (default value), constructor call will set once MainTested and MainInjector (with method ResetTemplate())</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;para/&gt;</span>It was made to avoid NUnit dependency with SetUp decorator</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;para/&gt;</span>If you want to ResetTemplate() at each test with NUnit by example,</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> you have to create a method decorated with [SetUp] and call ResetTemplate() in it</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> SetTemplateWithConstructor =&gt; <span class="hljs-literal">true</span>;

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Each mapping added into this container force a type to be used by its derived form during tests using TestInjector, </span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> useful when working on abstract component injected with Nixi</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">protected</span> AbstractComponentMappingContainer ComponentMappingContainer = <span class="hljs-literal">null</span>;

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Map a component type with a derived type into ComponentMappingContainer</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TAbstract&quot;&gt;</span>Component key type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TImplementation&quot;&gt;</span>Implementation type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddAbstractComponentMapping</span>&lt;<span class="hljs-title">TAbstract</span>, <span class="hljs-title">TImplementation</span>&gt;(<span class="hljs-params"></span>)
        <span class="hljs-keyword">where</span> TAbstract : Component
        <span class="hljs-keyword">where</span> TImplementation : class, TAbstract</span>
    {
        ComponentMappingContainer = ComponentMappingContainer ?? <span class="hljs-keyword">new</span> AbstractComponentMappingContainer();
        ComponentMappingContainer.Map&lt;TAbstract, TImplementation&gt;();
    }

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> Create an instance of the MonoBehaviourInjectable to test as well as its TestInjector which allows to expose the fields to </span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> test / mock with the Nixi approach</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;para/&gt;</span>If you want to ResetTemplate() at each test with NUnit by example,</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> you have to create a method decorated with [SetUp] and call ResetTemplate() in it</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResetTemplate</span>(<span class="hljs-params"></span>)</span>
    {
        MainTested = <span class="hljs-keyword">new</span> GameObject().AddComponent&lt;T&gt;();

        MainInjector = <span class="hljs-keyword">new</span> TestInjector(MainTested, InstanceName, ComponentMappingContainer);

        MainInjector.CheckAndInjectAll();
    }

    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> This constructor was made to avoid NUnit dependency, it will set MainTested instance and its TestInjector</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> named MainInjector using ResetTemplate() method only once.</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;para/&gt;</span>If you want to ResetTemplate() at each test with NUnit by example,</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> you have to create a method decorated with [SetUp] and call ResetTemplate() in it</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> You can suppress the first call on ResetTemplate (in this constructor) by setting value on SetTemplateWithConstructor to false</span>
    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InjectableTestTemplate</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">if</span> (SetTemplateWithConstructor)
            ResetTemplate();
    }
}
</div></code></pre>
<h3 id="how-to-use-injectabletesttemplate">How to use InjectableTestTemplate</h3>
<p>To use InjectableTestTemplate for your tests, create a test class that inherits from InjectableTestTemplate with a generic parameter that represents the class you want to test like in the example below.</p>
<blockquote>
<p>The generic parameter (the class you are testing) must have been inherited from MonoBehaviourInjectable.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sorcerer</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D colliderToInject;
}

<span class="hljs-comment">// Generic type (Sorcerer) must be a class inherited from MonoBehaviourInjectable</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SorcererTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">Sorcerer</span>&gt;
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestToExecute</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Sorcerer instance was successfully loaded</span>
        Assert.NotNull(MainTested);

        <span class="hljs-comment">// TestInjector instance was successfully loaded</span>
        Assert.NotNull(MainInjector);
    }
}
</div></code></pre>
<h2 id="tests-with-single-component">Tests with single component</h2>
<p>This part describes how to test the fields decorated with Nixi attributes concerning the single component cases.</p>
<p>You can read how to test your code for single component cases in the following parts :</p>
<ul>
<li><a href="#get-a-single-component-with-type">Get a single component with type</a></li>
<li><a href="#get-a-single-component-with-type-and-name">Get a single component of type with type and name</a></li>
<li><a href="#more-informations-about-getcomponent">More informations about GetComponent</a></li>
</ul>
<h3 id="get-a-single-component-with-type">Get a single component with type</h3>
<p>To get a single component, you can call GetComponent from the MainInjector and specify which type you want.</p>
<pre><code class="language-cs"><div>[<span class="hljs-meta">Test</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetComponent_OnlyWithFieldType</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Get the unique BoxCollider2D component in Sorcerer class</span>
    <span class="hljs-comment">// It was filled from TestInjector when the InjectableTestTemplate constructor was called</span>
    BoxCollider2D colliderGenerated = MainInjector.GetComponent&lt;BoxCollider2D&gt;();

    <span class="hljs-comment">// Check BoxCollider2D was built with TestInjector</span>
    Assert.NotNull(colliderGenerated);
}
</div></code></pre>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/></p>
<ul>
<li><strong>If not found an exception will be thrown</strong></li>
<li><strong>If more than one field with the same type are found in the class, an exception will be thrown</strong>.
<br/>It means that you have to pass the name of the field in GetComponent like <a href="#get-a-single-component-with-type-and-name">in this part</a>.</li>
</ul>
</blockquote>
<h3 id="get-a-single-component-with-type-and-name">Get a single component with type and name</h3>
<p>If several components of the same type are present in the class, <strong>the name of the field</strong> must be passed as a parameter.</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Sorcerer</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D firstCollider;

    [<span class="hljs-meta">NixInjectComponentFromChildren(<span class="hljs-meta-string">&quot;anyChildGameObjectName&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> BoxCollider2D secondCollider;
}

[<span class="hljs-meta">Test</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetComponent_WithFieldTypeAndFieldName</span>(<span class="hljs-params"></span>)</span>
{
    BoxCollider2D firstCollider = MainInjector.GetComponent&lt;BoxCollider2D&gt;(<span class="hljs-string">&quot;firstCollider&quot;</span>);
    BoxCollider2D secondCollider = MainInjector.GetComponent&lt;BoxCollider2D&gt;(<span class="hljs-string">&quot;secondCollider&quot;</span>);

    Assert.NotNull(firstCollider);
    Assert.NotNull(secondCollider);
    Assert.AreNotEqual(firstCollider.GetInstanceID(), secondCollider.GetInstanceID());
}
</div></code></pre>
<blockquote>
<p><strong><em>Exception(s)</em></strong><br/>
<strong>If not found an exception will be thrown</strong></p>
</blockquote>
<h3 id="more-informations-about-getcomponent">More informations about GetComponent</h3>
<p>For the tests, I wanted to reproduce as much as possible the parent / child relationship scheme between the components associated with the Nixi attributes, as well as carry over the names that we are supposed to find.</p>
<p>You can see how it was written in the following parts :</p>
<ul>
<li><a href="#nixinjectcomponentfromparent-and-nixinjectcomponentfromchildren-decorators">NixInjectComponentFromParent and NixInjectComponentFromChildren decorators</a></li>
<li><a href="#nixinjectcomponent-decorator">NixInjectComponent decorator</a></li>
<li><a href="#nixinjectrootcomponent-with-only-rootgameobjectname-parameter-decorator">NixInjectRootComponent with only rootGameObjectName parameter decorator</a></li>
<li><a href="#nixinjectrootcomponent-with-rootgameobjectname-and-subgameobjectname-parameters-decorator">NixInjectRootComponent with rootGameObjectName and subGameObjectName parameters decorator</a></li>
<li><a href="#nixinjectrootcomponent-special-case-where-you-want-your-maintested-instance-to-be-recognized-as-a-root-gameobject">NixInjectRootComponent, special case where you want your MainTested instance to be recognized as a root GameObject</a></li>
</ul>
<h4 id="nixinjectcomponentfromparent-and-nixinjectcomponentfromchildren-decorators">NixInjectComponentFromParent and NixInjectComponentFromChildren decorators</h4>
<p>For these decorators, we don't know how many generations there are between a child and the current GameObject (or a parent and the current GameObject), so I decided to :</p>
<ul>
<li>Not to create a link between them (transform.parent).</li>
<li>And change the name of the new GameObject to match &quot;gameObjectNameToFind&quot; parameter passed in the decorator.</li>
</ul>
<h4 id="nixinjectcomponent-decorator">NixInjectComponent decorator</h4>
<p>For this decorator, we know this is attached to the same GameObject as the MonoBehaviourInjectable (MainTested) instance, so it has the same GameObject, therefore the same transform and the same name.</p>
<h4 id="nixinjectrootcomponent-with-only-rootgameobjectname-parameter-decorator">NixInjectRootComponent with only rootGameObjectName parameter decorator</h4>
<p>For this decorator, it means only one root GameObject must have rootGameObjectName name.</p>
<p>That implies that :</p>
<ul>
<li>If you have many different types of components decorated with this decorator (with only rootGameObjectName parameter), they all will have the same GameObject but all these fields will have a different component injected.</li>
<li>If you have many identical types of components decorated with this decorator (with only rootGameObjectName parameter), they all will have the same GameObject and all these fields will have the same component injected.</li>
</ul>
<blockquote>
<p>If the instance with rootGameObjectName name does not exist, it is created for the tests.<br/>
If it already exists, the same instance will be used for every field decorated with the same NixInjectRootComponent in MainTested.</p>
</blockquote>
<blockquote>
<p>It also works when an injected field has a type derived from MonoBehaviourInjectable and one of its fields has the same NixInjectRootComponent (with same parameters and same type of field). You can see <a href="#recursion-in-testinjector">recursion part for more informations</a>.<br/>
The code below show an application of this point.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DummyController</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// code</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// 1) Create an instance of DummyController</span>
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;DummyControllerName&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> DummyController dummyController;

    <span class="hljs-comment">// 2) Create an instance of RecursionExample, fill this field with.</span>
    <span class="hljs-comment">// Then by recursion, the fields in the instance of RecursionExample are also injected </span>
    <span class="hljs-comment">// because its type derives from MonoBehaviourInjectable</span>
    <span class="hljs-comment">// See Recursion part for more informations</span>
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">private</span> RecursionExample recursionExample;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RecursionExample</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// 3) Then it is filled with the same instance as Example.dummyController</span>
    <span class="hljs-comment">// because Example is the class tested, RecursionExample is built after</span>
    <span class="hljs-comment">// and have to refer to the rootComponent previously generated</span>
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;DummyControllerName&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> DummyController dummyController;
}
</div></code></pre>
<h4 id="nixinjectrootcomponent-with-rootgameobjectname-and-subgameobjectname-parameters-decorator">NixInjectRootComponent with rootGameObjectName and subGameObjectName parameters decorator</h4>
<p>This is the same as for <a href="#nixinjectrootcomponent-with-only-rootgameobjectname-parameter-decorator">NixInjectRootComponent with only rootGameObjectName parameter decorator part</a>, the root GameObject will be instantiated if no instance already exists with the name rootGameObjectName (if it exists, the next operation will be done directly on the existing instance).</p>
<p>Then a GameObject will be instantiated with the name that matches the value contained in subGameObjectName (if it doesn't already exist) with the root GameObject as parent.</p>
<p>It implies :</p>
<ul>
<li>The same rules (from <a href="#nixinjectrootcomponent-with-only-rootgameobjectname-parameter-decorator">NixInjectRootComponent with only rootGameObjectName parameter decorator part</a>) apply on this child GameObject, this is just one level below.</li>
<li>Same goes for rules of instance crossing between all fields decorated with NixInjectRootComponent in MainTested and recursively from its fields injectables (you can see <a href="#recursion-in-testinjector">recursion part for more informations</a>).</li>
<li>Both constructor of NixInjectRootComponent can be combined on the same root GameObject (with name rootGameObjectName).</li>
</ul>
<p>Code example :</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// 1) Create an instance of AllControllers</span>
    <span class="hljs-comment">// 2) Create an instance of DummyController which has AllControllers as parent</span>
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;AllControllers&quot;</span>, <span class="hljs-meta-string">&quot;DummyController&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> DummyController dummyController;

    <span class="hljs-comment">// 3) Create an instance of RecursionExample, fill this field with.</span>
    <span class="hljs-comment">// Then by recursion, the fields of the instance of RecursionExample are also injected </span>
    <span class="hljs-comment">// because its type derives from MonoBehaviourInjectable</span>
    <span class="hljs-comment">// See Recursion part for more informations</span>
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">private</span> RecursionExample recursionExample;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RecursionExample</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// 4) Fill with the same intance as Example.dummyController (which has AllControllers </span>
    <span class="hljs-comment">// as parent) because Example is the class tested, RecursionExample is built after</span>
    <span class="hljs-comment">// and have to refer to the rootComponent previously generated</span>
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;AllControllers&quot;</span>, <span class="hljs-meta-string">&quot;DummyController&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> DummyController dummyController;
}
</div></code></pre>
<h4 id="nixinjectrootcomponent-special-case-where-you-want-your-maintested-instance-to-be-recognized-as-a-root-gameobject">NixInjectRootComponent, special case where you want your MainTested instance to be recognized as a root GameObject</h4>
<p>If you want a field decorated with NixInjectRootComponent to target MainTested as a root component, there is a property in InjectableTestTemplate to specify the name of MainTested instance.</p>
<p>If you do this and a field targets a root component with the name of MainTested, this field will be filled with the instance of MainTested.</p>
<pre><code class="language-cs"><div><span class="hljs-comment">// Class for MainTested</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MonsterController</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;SorcererController&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> SorcererController SorcererController;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SorcererController</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectRootComponent(<span class="hljs-meta-string">&quot;MonsterController&quot;</span>)</span>]
    <span class="hljs-keyword">private</span> MonsterController MonsterController;
}

<span class="hljs-comment">// MainTested = MonsterController instance tested</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RootTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">MonsterController</span>&gt;
{
    <span class="hljs-comment">// Set an InstanceName allows other components to refer to MainTested </span>
    <span class="hljs-comment">// as a root component</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">string</span> InstanceName =&gt; <span class="hljs-string">&quot;MonsterController&quot;</span>;

    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Instances_MustInject_EachOther</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Get other controller</span>
        SorcererController sorcererController = MainInjector.GetComponent&lt;SorcererController&gt;();

        <span class="hljs-comment">// Check correctly named</span>
        Assert.AreEqual(<span class="hljs-string">&quot;MonsterController&quot;</span>, MainTested.name);
        Assert.AreEqual(<span class="hljs-string">&quot;SorcererController&quot;</span>, sorcererController.name);            

        <span class="hljs-comment">// Check that both refer to each other</span>
        Assert.NotNull(MainTested.SorcererController);
        Assert.AreEqual(MainTested.SorcererController.GetInstanceID(), sorcererController.GetInstanceID());

        Assert.NotNull(sorcererController.MonsterController);
        Assert.AreEqual(sorcererController.MonsterController.GetInstanceID(), MainTested.GetInstanceID()); 
    }
}
</div></code></pre>
<h2 id="tests-with-multiple-components">Tests with multiple components</h2>
<p>This part describes how to test the fields decorated with Nixi attributes concerning the multiple components cases.</p>
<p>You can read how to test your code for multiple components cases in the following parts :</p>
<ul>
<li><a href="#fields-decorated-with-a-nixi-attribute-for-multiple-components-fields">Fields decorated with a Nixi attribute for multiple components fields</a></li>
<li><a href="#initenumerablecomponents">InitEnumerableComponents</a></li>
<li><a href="#initenumerablecomponentswithtypes">InitEnumerableComponentsWithTypes</a></li>
<li><a href="#initsingleenumerablecomponents">InitSingleEnumerableComponents</a></li>
<li><a href="#getenumerablecomponents">GetEnumerableComponents</a></li>
</ul>
<h3 id="fields-decorated-with-a-nixi-attribute-for-multiple-components-fields">Fields decorated with a Nixi attribute for multiple components fields</h3>
<p>For each field decorated with a Nixi attribute for multiple components injection, TestInjector will set these fields as empty and you will have to initialize them.</p>
<blockquote>
<p>This is because there is no way to know how many you want to test based on type only.</p>
</blockquote>
<p>It implies :</p>
<ul>
<li>Initializing a component field twice will throw an exception.</li>
<li>If you initialize a field with one or more components and if their type is derived from MonoBehaviourInjectable, TestInjector will recursively inject the fields of each instance (you can see <a href="#recursion-in-testinjector">recursion part for more informations</a>).</li>
<li>Is considered initialized, a multiple components field which is not empty.</li>
<li>A multi-component field can be at 3 different levels, each level has a separated injection :
<ul>
<li>Current level (itself at current GameObject level)</li>
<li>Parent level (NixInjectComponentsFromParent, parent GameObjects excluding itself)</li>
<li>Child level (NixInjectComponentsFromChildren, child GameObjects excluding itself)</li>
</ul>
</li>
<li>If you initialize several multi-component fields having the same enumerable type and the same level (current, child, parent): they will be filled with the same components.</li>
</ul>
<blockquote>
<p>As a <a href="#multiple-components-injection">reminder</a> : a multiple components field is a List/IEnumerable/Array with an enumerable type derived from Component.</p>
</blockquote>
<h3 id="initenumerablecomponents">InitEnumerableComponents</h3>
<p>You can initialize a field with several components at the same time specifying the number of instances you want to create.</p>
<p>All the components built are returned at the output of the method and if the enumerable type is derived from MonoBehaviourInjectable, TestInjector will recursively inject the fields of each instance (you can see <a href="#recursion-in-testinjector">recursion part for more informations</a>).</p>
<blockquote>
<p>If initialized at the current level (GameObjectLevel.Current by default), all instances will be attached to the MainTested GameObject (or on the instance recursively injected if the case is encountered).</p>
</blockquote>
<p>You can see an example below.</p>
<pre><code class="language-cs"><div><span class="hljs-comment">// Class tested</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HeroWithMultiLevelWeapon</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponentsFromChildren</span>] <span class="hljs-comment">// Children level</span>
    <span class="hljs-keyword">public</span> List&lt;Weapon&gt; ChildrenWeapons;

    [<span class="hljs-meta">NixInjectComponents</span>] <span class="hljs-comment">// Current level</span>
    <span class="hljs-keyword">public</span> List&lt;Weapon&gt; Weapons;

    [<span class="hljs-meta">NixInjectComponentsFromParent</span>] <span class="hljs-comment">// Parent level</span>
    <span class="hljs-keyword">public</span> List&lt;Weapon&gt; ParentWeapons;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HeroWithMultiLevelWeaponTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">HeroWithMultiLevelWeapon</span>&gt;
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitEnumerable_ShouldFillAtDifferentLevels</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Init 4 weapons at children level</span>
        IEnumerable&lt;Weapon&gt; childrenWeapons = MainInjector.InitEnumerableComponents&lt;Weapon&gt;(GameObjectLevel.Children, <span class="hljs-number">4</span>);

        <span class="hljs-comment">// Init 2 weapons at current level (attached to MainTested GameObject)</span>
        IEnumerable&lt;Weapon&gt; weapons = MainInjector.InitEnumerableComponents&lt;Weapon&gt;(<span class="hljs-number">2</span>);

        <span class="hljs-comment">// Init 3 weapons at parent level</span>
        IEnumerable&lt;Weapon&gt; parentWeapons = MainInjector.InitEnumerableComponents&lt;Weapon&gt;(GameObjectLevel.Parent, <span class="hljs-number">3</span>);

        Assert.AreEqual(<span class="hljs-number">4</span>, MainTested.ChildrenWeapons.Count);
        Assert.AreEqual(<span class="hljs-number">2</span>, MainTested.Weapons.Count);
        Assert.AreEqual(<span class="hljs-number">3</span>, MainTested.ParentWeapons.Count);

        <span class="hljs-comment">// Cannot init twice at any level</span>
        Assert.Throws&lt;TestInjectorException&gt;(() =&gt; MainInjector.InitEnumerableComponents&lt;Weapon&gt;(<span class="hljs-number">2</span>));
    }
}
</div></code></pre>
<h3 id="initenumerablecomponentswithtypes">InitEnumerableComponentsWithTypes</h3>
<p>You can initialize a field with multiple components at the same time by passing one or more types that are of the same type or derived from the enumerable type you want to create.</p>
<p>All the components built are returned at the output of the method and if the enumerable type is derived from MonoBehaviourInjectable, TestInjector will recursively inject the fields of each instance (you can see <a href="#recursion-in-testinjector">recursion part for more informations</a>).</p>
<blockquote>
<p>If initialized at the current level (GameObjectLevel.Current by default), all instances will be attached to the MainTested GameObject (or on the instance recursively injected if the case is encountered).</p>
</blockquote>
<p>You can see an example below.</p>
<blockquote>
<p>For the line with ResetTemplate() method call, you can read what it is for <a href="#resettemplate-method">into this part</a>.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> : <span class="hljs-title">MonoBehaviour</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span> {}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Farm</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponentsFromParent</span>]
    <span class="hljs-keyword">public</span> List&lt;Cat&gt; CatsParent;

    [<span class="hljs-meta">NixInjectComponentsFromParent</span>]
    <span class="hljs-keyword">public</span> List&lt;Animal&gt; AnimalsParent;

    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">public</span> List&lt;Cat&gt; Cats;

    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">public</span> List&lt;Animal&gt; Animals;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FarmTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">Farm</span>&gt;
{
    <span class="hljs-comment">// Force MainTested to be rebuilt at each test,</span>
    <span class="hljs-comment">// see part concerning ResetTemplate to have more explanations</span>
    [<span class="hljs-meta">SetUp</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitTests</span>(<span class="hljs-params"></span>)</span>
    {
        ResetTemplate();
    }

    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitEnumerableComponentsWithTypes_ShouldLoadType_AndParentType</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Init 2 cat at parent level</span>
        IEnumerable&lt;Cat&gt; cats = MainInjector.InitEnumerableComponentsWithTypes&lt;Cat&gt;(GameObjectLevel.Parent, <span class="hljs-keyword">typeof</span>(Cat), <span class="hljs-keyword">typeof</span>(Cat));

        <span class="hljs-comment">// At current level, nothing is instantiated</span>
        Assert.IsEmpty(MainTested.Cats);
        Assert.IsEmpty(MainTested.Animals);

        <span class="hljs-comment">// Parent level (GameObjectLevel.Parent parameter targeting NixInjectComponentsFromParent decorator in InitEnumerableComponentsWithTypes)</span>
        Assert.AreEqual(<span class="hljs-number">2</span>, MainTested.CatsParent.Count);

        <span class="hljs-comment">// It work over inheritance</span>
        Assert.AreEqual(<span class="hljs-number">2</span>, MainTested.AnimalsParent.Count);
    }

    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitEnumerableComponentsWithTypes_ShouldOnlyLoadType_AndNotParentType</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Init a cat and a dog at current level (attached to MainTested GameObject)</span>
        <span class="hljs-comment">// This line is equivalent to :</span>
        <span class="hljs-comment">// IEnumerable&lt;Animal&gt; animals = MainInjector.InitEnumerableComponentsWithTypes&lt;Animal&gt;(GameObjectLevel.Current, typeof(Cat), typeof(Dog));</span>
        IEnumerable&lt;Animal&gt; animals = MainInjector.InitEnumerableComponentsWithTypes&lt;Animal&gt;(<span class="hljs-keyword">typeof</span>(Cat), <span class="hljs-keyword">typeof</span>(Dog));
        
        <span class="hljs-comment">// At parent level, nothing is instantiated</span>
        Assert.IsEmpty(MainTested.CatsParent);
        Assert.IsEmpty(MainTested.AnimalsParent);

        <span class="hljs-comment">// Empty because Animal type is not Cat type</span>
        <span class="hljs-comment">// Generic type of InitEnumerableComponentsWithTypes&lt;Animal&gt; define </span>
        <span class="hljs-comment">// which enumerable type is targeted on fields decorated with NixInjectComponents</span>
        Assert.IsEmpty(MainTested.Cats);

        <span class="hljs-comment">// Cat and Dog are Animal and InitEnumerableComponentsWithTypes&lt;Animal&gt; target</span>
        <span class="hljs-comment">// fields with enumerable type &quot;Animal&quot;</span>
        Assert.AreEqual(<span class="hljs-number">2</span>, MainTested.Animals.Count);
    }
}
</div></code></pre>
<h3 id="initsingleenumerablecomponents">InitSingleEnumerableComponents</h3>
<p>It is possible to initialize a field with only one component into a multiple components field.
The method returns this instance and not an IEnumerable.</p>
<p>If this component is derived from MonoBehaviourInjectable, TestInjector will recursively inject all its fields (you can see <a href="#recursion-in-testinjector">recursion part for more informations</a>).</p>
<blockquote>
<p>If initialized at the current level (GameObjectLevel.Current by default), all instances will be attached to the MainTested GameObject (or on the instance recursively injected if the case is encountered).</p>
</blockquote>
<p>You can see an example below.</p>
<pre><code class="language-cs"><div>[<span class="hljs-meta">Test</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SingleInit_InMultiComponent</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Init single cat at current level (attached to MainTested GameObject)</span>
    <span class="hljs-comment">// This line is equivalent to :</span>
    <span class="hljs-comment">// Cat cat = MainInjector.InitSingleEnumerableComponent&lt;Cat&gt;(GameObjectLevel.Current);</span>
    Cat cat = MainInjector.InitSingleEnumerableComponent&lt;Cat&gt;();

    <span class="hljs-comment">// At parent level, nothing is instantiated</span>
    Assert.IsEmpty(MainTested.CatsParent);
    Assert.IsEmpty(MainTested.AnimalsParent);

    <span class="hljs-comment">// Only one instantiated</span>
    Assert.AreEqual(<span class="hljs-number">1</span>, MainTested.Cats.Count);
    Assert.AreEqual(<span class="hljs-number">1</span>, MainTested.Animals.Count);

    Assert.AreEqual(cat.GetInstanceID(), MainTested.Cats[<span class="hljs-number">0</span>].GetInstanceID());
    Assert.AreEqual(cat.GetInstanceID(), MainTested.Animals[<span class="hljs-number">0</span>].GetInstanceID());
}
</div></code></pre>
<h3 id="getenumerablecomponents">GetEnumerableComponents</h3>
<p>Although you can initialize a field of multiple components with multiple values and retrieve them from the initialization method, you may want to re-access a field's components to see the new values if, by example, a method instantiates or destroys an element of this same list.</p>
<p>The initialization is mainly used to have an original state to test, but you can see the values inside at any time like in the example below.</p>
<blockquote>
<p>The approach is like <a href="#get-a-single-component-with-type">GetComponent with type</a> and <a href="#get-a-single-component-with-type-and-name">GetComponent with type and name</a> from TestInjector, you don't have to precise the level (current, parent, child) but only the type if there is only one multiple components field which has its enumerable type equal to the type you are looking for.</p>
</blockquote>
<blockquote>
<p>If there is multiple result, you have to pass the name of the field as parameter to find the one you are targeting.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Monster</span> : <span class="hljs-title">MonoBehaviour</span> {}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Spawner</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">public</span> List&lt;Monster&gt; Monsters;

    <span class="hljs-function"><span class="hljs-keyword">public</span> Monster <span class="hljs-title">Spawn</span>(<span class="hljs-params"></span>)</span>
    {
        Monster newMonster = <span class="hljs-keyword">new</span> GameObject().AddComponent&lt;Monster&gt;();

        Monsters.Add(newMonster);

        <span class="hljs-keyword">return</span> newMonster;
    }
}

[<span class="hljs-meta">Test</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Initialisation_ThenSpawn_ShouldReturnAllValues</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-comment">// Init 2 monsters</span>
    List&lt;Monster&gt; monstersInjected = MainInjector.InitEnumerableComponents&lt;Monster&gt;(<span class="hljs-number">2</span>).ToList();

    <span class="hljs-comment">// 3 monsters now</span>
    Monster monsterAddedFromClass = MainTested.Spawn();

    <span class="hljs-comment">// Get all monsters (first 2 initialized + the last which spawned from the previous line)</span>
    List&lt;Monster&gt; allMonsters = MainInjector.GetEnumerableComponents&lt;Monster&gt;().ToList();
    
    Assert.AreEqual(<span class="hljs-number">3</span>, allMonsters.Count());
    Assert.AreEqual(<span class="hljs-number">3</span>, MainTested.Monsters.Count);

    Assert.AreEqual(monstersInjected[<span class="hljs-number">0</span>].GetInstanceID(), allMonsters[<span class="hljs-number">0</span>].GetInstanceID());
    Assert.AreEqual(monstersInjected[<span class="hljs-number">1</span>].GetInstanceID(), allMonsters[<span class="hljs-number">1</span>].GetInstanceID());
    Assert.AreEqual(monsterAddedFromClass.GetInstanceID(), allMonsters[<span class="hljs-number">2</span>].GetInstanceID());
}
</div></code></pre>
<h2 id="tests-with-mockable-fields">Tests with mockable fields</h2>
<p>This part describes how to test the mockables fields decorated with Nixi attributes (concerning fields with interface type).</p>
<p>You can read how to test your code for mockables fields cases in the following parts :</p>
<ul>
<li><a href="#inject-and-read-fields">Inject and read fields</a></li>
<li><a href="#inject-field-for-nixinjectfromcontainer-or-serializefield">Inject field for NixInjectFromContainer or SerializeField</a></li>
<li><a href="#mock-single-component-field-decorating-an-interface-eg--nixinjectcomponent">Mock single component field decorating an interface (e.g : NixInjectComponent)</a></li>
<li><a href="#mock-multiple-components-field-having-an-interface-as-enumerable-type-eg--nixinjectcomponents">Mock multiple components field having an interface as enumerable type (e.g : NixInjectComponents)</a></li>
</ul>
<h3 id="inject-and-read-fields">Inject and read fields</h3>
<p>There are several cases where you can <strong>inject</strong> or <strong>read</strong> values directly into fields using TestInjector.</p>
<p>This concerns :</p>
<ul>
<li>Fields decorated <a href="#mock-on-nixinjectfromcontainer-and-serializefield-decorators">with NixInjectFromContainer</a>.</li>
<li>Fields decorated <a href="#mock-on-nixinjectfromcontainer-and-serializefield-decorators">with SerializeField</a>.</li>
<li>Fields that have an interface type and are decorated with a Nixi attribute to <a href="#fields-with-type-derived-from-interface">inject a single component</a>.</li>
<li>Fields that have IEnumerable, List or array type with an interface as enumerable type, decorated with a Nixi attribute to <a href="#enumerable-fields-with-enumerable-type-derived-from-interface">inject multiple component</a>.</li>
</ul>
<blockquote>
<p>You can call InjectField and ReadField with type only, if there is only one field which has the targeted type.</p>
<p>If many are found, you have to specify the field name.</p>
</blockquote>
<h3 id="inject-field-for-nixinjectfromcontainer-or-serializefield">Inject field for NixInjectFromContainer or SerializeField</h3>
<p>You can create a mock in the test and <strong>inject</strong> all the fields :</p>
<ul>
<li>With an interface type.</li>
<li>Decorated with NixInjectFromContainer or SerializeField.</li>
</ul>
<p>You can also <strong>read</strong> the values in these fields.</p>
<p>You can see an example below.</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IStrategy</span>
{
    <span class="hljs-keyword">string</span> Title { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StrategyImplementation</span> : <span class="hljs-title">IStrategy</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Title { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StrategyImplementation</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> title</span>)</span>
    {
        Title = title;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Warrior</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">private</span> IStrategy strategy;

    [<span class="hljs-meta">SerializeField</span>]
    <span class="hljs-keyword">private</span> Image firstImage;

    [<span class="hljs-meta">SerializeField</span>]
    <span class="hljs-keyword">private</span> Image secondImage;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WarriorTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">Warrior</span>&gt;
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InjectAndReadInterface</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Read field before inject should return null</span>
        Assert.Null(MainInjector.ReadField&lt;IStrategy&gt;());

        <span class="hljs-comment">// Here I use an implementation</span>
        <span class="hljs-comment">// but this could be more pratical to use library like Mock/NSubstitute/etc.</span>
        IStrategy strategyInjected = <span class="hljs-keyword">new</span> StrategyImplementation(<span class="hljs-string">&quot;Hit and run&quot;</span>);
        
        <span class="hljs-comment">// Inject</span>
        MainInjector.InjectField(strategyInjected);

        <span class="hljs-comment">// Read should return the StrategyImplementation</span>
        IStrategy strategyFromRead = MainInjector.ReadField&lt;IStrategy&gt;();

        <span class="hljs-comment">// Should not be null anymore and implementation should be the same</span>
        Assert.IsNotNull(strategyFromRead);
        Assert.AreEqual(<span class="hljs-string">&quot;Hit and run&quot;</span>, strategyFromRead.Title);
    }

    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InjectAndReadSerializedField_WithTwoSameFieldType</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Read field before inject should return null for both image fields</span>
        Assert.Null(MainInjector.ReadField&lt;Image&gt;(<span class="hljs-string">&quot;firstImage&quot;</span>));
        Assert.Null(MainInjector.ReadField&lt;Image&gt;(<span class="hljs-string">&quot;secondImage&quot;</span>));

        Image imageInjected = <span class="hljs-keyword">new</span> GameObject().AddComponent&lt;Image&gt;();

        <span class="hljs-comment">// Inject into Image field named &quot;FirstImage&quot;,</span>
        <span class="hljs-comment">// we have to specify the name because there are two field with Image type</span>
        <span class="hljs-comment">// (contrary to strategy field)</span>
        MainInjector.InjectField(imageInjected, <span class="hljs-string">&quot;firstImage&quot;</span>);

        <span class="hljs-comment">// Read should return the same Image</span>
        Image imageFromRead = MainInjector.ReadField&lt;Image&gt;(<span class="hljs-string">&quot;firstImage&quot;</span>);

        <span class="hljs-comment">// Second image still null</span>
        Assert.IsNull(MainInjector.ReadField&lt;Image&gt;(<span class="hljs-string">&quot;secondImage&quot;</span>));

        <span class="hljs-comment">// First image is not null anymore and imageFromRead should be the same as imageInjected</span>
        Assert.IsNotNull(imageFromRead);
        Assert.AreEqual(imageInjected.GetInstanceID(), imageFromRead.GetInstanceID());
    }
}
</div></code></pre>
<h3 id="mock-single-component-field-decorating-an-interface-eg--nixinjectcomponent">Mock single component field decorating an interface (e.g : NixInjectComponent)</h3>
<p>You can create a mock in the test and <strong>inject</strong> all the fields :</p>
<ul>
<li>With an interface type.</li>
<li>Decorated with a Nixi attribute for single component injection.</li>
</ul>
<p>You can also <strong>read</strong> the values in these fields.</p>
<p>You can see an example below.</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IOption</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> OptionValue { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Option</span> : <span class="hljs-title">IOption</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> OptionValue { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; } = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Option</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> optionValue</span>)</span>
    {
        OptionValue = optionValue;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameOptionsMenu</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">public</span> IOption Option;

    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">public</span> List&lt;IOption&gt; Options;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameOptionsMenuTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">GameOptionsMenu</span>&gt;
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InjectAndReadInterface</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Read field before inject should return null</span>
        Assert.Null(MainInjector.ReadField&lt;IOption&gt;());

        <span class="hljs-comment">// Here I use an implementation</span>
        <span class="hljs-comment">// but this could be more pratical to use library like Mock/NSubstitute/etc.</span>
        IOption optionInjected = <span class="hljs-keyword">new</span> Option(<span class="hljs-number">4</span>);

        <span class="hljs-comment">// Inject</span>
        MainInjector.InjectField(optionInjected);

        <span class="hljs-comment">// Read should return Option implementation</span>
        IOption optionFromRead = MainInjector.ReadField&lt;IOption&gt;();

        <span class="hljs-comment">// Should not be null anymore and implementation should be the same</span>
        Assert.IsNotNull(optionFromRead);
        Assert.AreEqual(<span class="hljs-number">4</span>, optionFromRead.OptionValue);
    }
}
</div></code></pre>
<h3 id="mock-multiple-components-field-having-an-interface-as-enumerable-type-eg--nixinjectcomponents">Mock multiple components field having an interface as enumerable type (e.g : NixInjectComponents)</h3>
<p>You can create a mock in the test and <strong>inject</strong> all the IEnumerable, List or array fields :</p>
<ul>
<li>Having an interface as enumerable type.</li>
<li>Decorated with a Nixi attribute for multiple components injection.</li>
</ul>
<p>You can also <strong>read</strong> the values in these fields.</p>
<blockquote>
<p>It is different from initializing multiple components field, these fields are considered as fields to mock. It won't inject all fields with same decorator and type (contrary to <a href="#initenumerablecomponents">InitEnumerableComponents</a> and their variations)</p>
</blockquote>
<p>You can see an example below.</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IOption</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> OptionValue { <span class="hljs-keyword">get</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Option</span> : <span class="hljs-title">IOption</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> OptionValue { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; } = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Option</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> optionValue</span>)</span>
    {
        OptionValue = optionValue;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameOptionsMenu</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">public</span> IOption Option;

    [<span class="hljs-meta">NixInjectComponents</span>]
    <span class="hljs-keyword">public</span> List&lt;IOption&gt; Options;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameOptionsMenuTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">GameOptionsMenu</span>&gt;
{
    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InjectAndRead_InterfaceEnumerable</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Read field before inject should return null</span>
        Assert.Null(MainInjector.ReadField&lt;List&lt;IOption&gt;&gt;());

        <span class="hljs-comment">// Here I use an implementation</span>
        <span class="hljs-comment">// but this could be more pratical to use library like Mock/NSubstitute/etc.</span>
        List&lt;IOption&gt; optionsInjected = <span class="hljs-keyword">new</span> List&lt;IOption&gt;
        {
            <span class="hljs-keyword">new</span> Option(<span class="hljs-number">123</span>)
        };

        <span class="hljs-comment">// Inject</span>
        MainInjector.InjectField(optionsInjected);

        <span class="hljs-comment">// Read should return the IOption list with Option implementation</span>
        List&lt;IOption&gt; optionsFromRead = MainInjector.ReadField&lt;List&lt;IOption&gt;&gt;();

        <span class="hljs-comment">// Should not be null anymore and implementation should be the same</span>
        Assert.IsNotNull(optionsFromRead);
        Assert.AreEqual(<span class="hljs-number">1</span>, optionsFromRead.Count);
        Assert.AreEqual(<span class="hljs-number">123</span>, optionsFromRead[<span class="hljs-number">0</span>].OptionValue);
    }
}
</div></code></pre>
<h2 id="details-of-other-features-of-injectabletesttemplate">Details of other features of InjectableTestTemplate</h2>
<p>There are other features concerning InjectableTestTemplate if you want to use them, you can read the following parts:</p>
<ul>
<li><a href="#instancename-property">InstanceName property</a></li>
<li><a href="#resettemplate-method">ResetTemplate method</a></li>
<li><a href="#settemplatewithconstructor-property">SetTemplateWithConstructor property</a></li>
<li><a href="#using-abstractcomponentmappingcontainer">Using AbstractComponentMappingContainer</a></li>
<li><a href="#template-with-nunit-framework">Template with NUnit framework</a></li>
</ul>
<h3 id="instancename-property">InstanceName property</h3>
<p><a href="#nixinjectrootcomponent-special-case-where-you-want-your-maintested-instance-to-be-recognized-as-a-root-gameobject">You can refer to this part</a> to have informations about InstanceName usages.</p>
<h3 id="resettemplate-method">ResetTemplate method</h3>
<p>This method resets the MainTested instance as well as the TestInjector instance.<br/>
It is called once in the constructor of InjectableTestTemplate if SetTemplateWithConstructor has its default value (true).</p>
<p>It is useful in cases where you need to reset these parameters for each test.<br/>
If you are using NUnit framework you can create a method decorated with [SetUp] and call ResetTemplate() in it.</p>
<p>You can see an example below :</p>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">ClassToTest</span>&gt;
{
    <span class="hljs-comment">// In NUnit framework [SetUp] decorator means :</span>
    <span class="hljs-comment">// call this method before each test</span>
    [<span class="hljs-meta">SetUp</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitTests</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Will reset MainTested and MainInjector before each test</span>
        ResetTemplate();
    }
}
</div></code></pre>
<p>The adaptated template for NUnit is shown <a href="#template-with-nunit-framework">in this part</a>.</p>
<h3 id="settemplatewithconstructor-property">SetTemplateWithConstructor property</h3>
<p>If true (default value), the constructor of InjectableTestTemplate will create once a MainTested instance and a MainInjector instance <a href="#resettemplate-method">with the ResetTemplate method</a>.</p>
<p>If false, InjectableTestTemplate constructor will do nothing special.</p>
<h3 id="using-abstractcomponentmappingcontainer">Using AbstractComponentMappingContainer</h3>
<p>If you instantiate a component that Unity considers abstract at compile time (such as Renderer) Unity will log an error.</p>
<p>Everytime TestInjector instantiate a component (into single or multiple component(s) field), if this type is abstract, Unity will log the same error.</p>
<blockquote>
<p>If you do new GameObject().AddComponent<Renderer>() Unity will log the following error :</p>
<p><em>Cannot add component of type 'Renderer' because it is abstract. Add component of type that is derived from 'Renderer' instead).</em></p>
</blockquote>
<p>To solve this problem, there is a special container that allows to map abstract types with derived types (these mappings are called AbstractMapping in the code).</p>
<blockquote>
<p>This container is in the InjectableTestTemplate.</p>
</blockquote>
<p>Each mapping added into this container force a type to be used by its derived form during tests using TestInjector.</p>
<p>You can see how to map an abstract mapping in the code example below.</p>
<blockquote>
<p>Abstract mappings can be done on non-abstract types but for the moment I didn't see any use, I didn't lock it in case someone finds a use for it (in which case the name is no longer suitable).</p>
</blockquote>
<blockquote>
<p>To avoid complicated cases around handling transform declinaisons, it is not possible to map Transform type.</p>
</blockquote>
<pre><code class="language-cs"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractComponentExample</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    [<span class="hljs-meta">NixInjectComponent</span>]
    <span class="hljs-keyword">public</span> Renderer Renderer;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AbstractComponentTests</span> : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">AbstractComponentExample</span>&gt;
{
    <span class="hljs-comment">// Boolean in the scope of the class because the log is created before the test</span>
    <span class="hljs-comment">// It is the variable to check if an error log is returned</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> abstractErrorWasLog = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// By default ResetTemplate is called once when InjectableTestTemplate constructor is called</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ResetTemplate</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-comment">// Force TestInjector to use MeshRenderer everytime a component with type Renderer has to be instantiated by it</span>
        AddAbstractComponentMapping&lt;Renderer, MeshRenderer&gt;();

        <span class="hljs-comment">// Subscribe to Unity console/logger</span>
        Application.logMessageReceived += Application_logMessageReceived;

        <span class="hljs-comment">// Reset MainTested and MainInjector</span>
        <span class="hljs-keyword">base</span>.ResetTemplate();
    }

    <span class="hljs-comment">// Method subscribed to Unity console/logger</span>
    <span class="hljs-comment">// Change abstractErrorWasLog to true if an error concerning abstract component construction is logged by Unity</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Application_logMessageReceived</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> condition, <span class="hljs-keyword">string</span> stackTrace, LogType type</span>)</span>
    {
        abstractErrorWasLog = condition.StartsWith(<span class="hljs-string">&quot;Cannot add component of type &#x27;Renderer&#x27; because it is abstract&quot;</span>);
    }

    [<span class="hljs-meta">Test</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Check_AbstractError_WasNotLog</span>(<span class="hljs-params"></span>)</span>
    {
        Assert.False(abstractErrorWasLog);
    }
}
</div></code></pre>
<h3 id="template-with-nunit-framework">Template with NUnit framework</h3>
<p>I don't know if there are other ways to test your code from Unity with something other than the NUnit framework, but I made the choice to not depend on this library in case it might suit someone.</p>
<p>This is why there is no decorator like &quot;SetUp&quot; in InjectableTestTemplate and why I created a constructor that inits the class even though I know it won't be call on every test, for that you can <a href="#resettemplate-method">read this part</a>.</p>
<p>You can read a complete code template based on NUnit below.</p>
<pre><code class="language-cs"><div><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Test template for MonoBehaviourInjectable using NUnit,</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> it creates an instance of the MonoBehaviourInjectable and use TestInjector </span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> to specially handle dependency injection for testing</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InjectableNUnitTemplate</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">InjectableTestTemplate</span>&lt;<span class="hljs-title">T</span>&gt;
    <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">MonoBehaviourInjectable</span>
{
    <span class="hljs-comment">// False because InitTests will ResetTemplate before each test</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">bool</span> SetTemplateWithConstructor =&gt; <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// Call ResetTemplate (resets the MainTested instance as well as the TestInjector instance) before each test</span>
    [<span class="hljs-meta">SetUp</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitTests</span>(<span class="hljs-params"></span>)</span>
    {
        ResetTemplate();
    }
}

<span class="hljs-comment">// I created this test class only to show how to use this new</span>
<span class="hljs-comment">// template and also to show that the instance of MainTested changes</span>
<span class="hljs-comment">// with each test called (MainInjector also changes with each test).</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NUnitExampleTests</span> : <span class="hljs-title">InjectableNUnitTemplate</span>&lt;<span class="hljs-title">Player</span>&gt;
{
    <span class="hljs-comment">// Store the last MainTested instanceId</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> lastInstanceId;

    <span class="hljs-comment">// This test will be run first</span>
    <span class="hljs-comment">// It is not recommended to use the &quot;Order&quot; parameter</span>
    <span class="hljs-comment">// because each test must be independent and not wait</span>
    <span class="hljs-comment">// for another to be executed</span>
    [<span class="hljs-meta">Test, Order(0)</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotRecommended_OrderedTest_ToInitInstanceId</span>(<span class="hljs-params"></span>)</span>
    {
        lastInstanceId = MainTested.GetInstanceID();
    }

    <span class="hljs-comment">// This test will be run second</span>
    <span class="hljs-comment">// The MainTested instanceId must have changed</span>
    [<span class="hljs-meta">Test, Order(1)</span>]
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InstanceShouldChange_AfterFirstTest</span>(<span class="hljs-params"></span>)</span>
    {
        Assert.AreNotEqual(lastInstanceId, MainTested.GetInstanceID());
    }
}
</div></code></pre>
<h2 id="special-cases-1">Special cases</h2>
<h3 id="multiple-transform-components">Multiple Transform components</h3>
<p>If you are using TestInjector on a class with multiple Transform fields decorated with Nixi attributes (for single or multiple components injection):</p>
<ul>
<li>If they all have the same type the injection will work.</li>
<li>If there are at least two different Transform types (Transform with RectTransform for example), TestInjector will raise an exception.</li>
</ul>
<p>I blocked it because Unity only allows one type of Transform on each GameObject.</p>
<h1 id="support">Support</h1>
<p>If you encounter any troubleshooting, you can :</p>
<ul>
<li>Create a ticket on the project : <a href="https://github.com/f-antoine/Nixi">https://github.com/f-antoine/Nixi</a></li>
<li>Or contact me at this address : <a href="mailto:nixi.unity@gmail.com">nixi.unity@gmail.com</a></li>
</ul>

    </body>
    </html>